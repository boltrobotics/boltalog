---
layout: post
title: "Log and metric reporting. Part 1"
---
## Problem
Every time I want to add or change a log line in the source code, the same thoughts start creeping in:

* SVV will need my help to fix a failing automated test because of my changes
* Tech writer will need questions answered to create release notes
* Sys admins will want easy-to-reach document to make use of the log event
* The modified log call may cause degradation during runtime 
* The change may trigger a debate about the log format

It might be a good idea to:

* Add such details to code submission so that along with the code history, there won't be many questions from SVV and tech writer
* Create, share and follow the log format standard to avoid style-related discussions
* Ensure that log changes don't affect the performance negatively by using better techniques

Quite often things don't turn out as planned:

* It takes a lot of time to make clear and descriptive comments. Some duplication between the code and comments is unavoidable, that gets annoying fast
* It is hard to agree on a standard: one wants square brackets, another curly braces, and so on. After agreement, the format still gets messed up
* Optimized code may be inconvenient to use, it may just look like needless clutter after a while

Still, I want to improve the process, be more efficient so that I have more time to do other things. What if I automate something and move stuff around so it is easier for everybody to use?

## Improvements
Let's consider them one at a time.

#### Optimizing Log Calls
The code below has two tests. The goal is to measure the cost of calling log function while trying to log an event with LOG\_INFO level when program is instructed to output only LOG\_WARNING and above ([Github](https://github.com/svkapustin/strong-log/blob/master/src/test/doc_log_call.cpp#L1-L30)):

```c++
  1 #include <gtest/gtest.h>
  2 #include <syslog.h>
  3 #include <iostream>
  4     
  5 int log_level_ = LOG_WARNING;
  6 
  7 void log(const std::string&) {
  8     if (LOG_INFO <= log_level_) {
  9         std::cout << "Event is output" << std::endl;
 10     }
 11 }
 12 
 13 std::string getStuffSlowly() {
 14     std::string blah = "hmmm... blah blah";
 15     
 16     for (int i = 0; i < 27; i++) {
 17         blah += blah;
 18     }
 19     return blah;
 20 }
 21 
 22 TEST(Doc, BadLogCall) {
 23     log(getStuffSlowly());
 24 }
 25 
 26 TEST(Doc, GoodLogCall) {
 27     if (LOG_INFO <= log_level_) {
 28         log(getStuffSlowly());
 29     }
 30 }
```
On my machine, the result is: 
    
```
[ RUN      ] Doc.BadLogCall
[       OK ] Doc.BadLogCall (2680 ms)
[ RUN      ] Doc.GoodLogCall
[       OK ] Doc.GoodLogCall (0 ms)
```

Given the speed advantage, I'd want to check the log level before even gathering the data for the log call.

However, there is a new problem: these checks will clutter my code. Even worse, I can mess up the comparison operator at a first lapse of concentration. And of course, the problem will be discovered in production later.

To reduce the clutter, I can use macros ([Github](https://github.com/svkapustin/strong-log/blob/master/src/test/doc_log_call.cpp#L32-L39)):

```c++
 32 #define onLogEvent(slow_stuff) \
 33     if (LOG_INFO <= log_level_) { \
 34         log(slow_stuff); \
 35     }
 36
 37 TEST(Doc, GoodLogCallMacro) {
 38     onLogEvent(getStuffSlowly());
 39 }
```

With this code, only one log statement is used in the vicinity of other logic. So far so good. But what about the time spent typing the macro? What about the rest? Let's dig deeper in [Part 2](/Logger2).
