---
layout: post
title: "Log and metric reporting. Part 2"
---
In [Part 1]({{ site.baseurl }}/Logger), I decided to use macros to optimize log calls. Instead of typing the macros manually, I wanted to have them auto-generated. The code generator will require event definitions such as event name, parameters, priority level and others. That information is stored in a model. Code generation will help me to:

* **Save time**<br>
My program emits quite a few events. Each event uses similar processing steps, i.e. check priority level, format the values, pass the event to the next stage. By having those common steps generated, my initial effort multiplies in value
* **Eliminate errors in code and log format**<br>
After I debugged my first generated macro and corresponding implementation, the subsequent ones will be replicated from the working code
* **Keep event definition and documentation co-located and in sync**<br>
Since I'll use a model to define events, I might as well use that same model to describe them. The close proximity of the definition and documentation lowers the barrier of keeping the documentation up to date. A source that holds that information in one place is easier and more useful to deal with for reference and generating other artefacts from

### Code Generator

[GSL Universal Code Generator](https://github.com/imatix/gsl#overview) exists for the purpose of code generation. Its documentation is clear, the tool is flexible and easy to use. GSL uses XML for defining models and its own scripting language for code templates.

### Model

Here is an example model I'll use for prototyping ([Github](https://github.com/svkapustin/strong-log/blob/master/model/log_model_example.xml#L7-L25)):

```xml
<?xml version="1.0" ?>
<log>
    <event id="1" name="onLogEventA" level="LOG_INFO">
        <doc>Log is emitted when so and so occurs.</doc>
        <param name="param1" type="int32_t" doc="description"/>
        <param name="param2" type="int8_t" />
    </event>
    <event id="2" name="onLogEventB" level="LOG_WARNING">
        <param name="param1" type="uint16_t" doc="- description"/>
        <param name="param2" type="const std::string&" doc="+ description"/>
    </event>
    <event id="3" name="onLogEventC" level="LOG_DEBUG">
        <doc>Log is emitted when so and so occurs.</doc>
        <param name="p1" type="uint64_t"/>
        <param name="p2" type="const std::string&"/>
        <param name="p3" type="const std::string&"/>
        <param name="p4" type="uint8_t"/>
    </event>
</log>
```
The model can be structured any way you want. I target simplicity as a primary criteria. This model should:

* **Borrow concepts**<br>
It is too easy to invent new concepts, the problem is that there are already so many to remember. So, instead of defining my own parameter types, I'll use C/C++ types. For priority levels I'll use syslog's definitions
* **Define directly translatable components**<br>
For example, C++ can use STL's string type, in the source code I'll use it as "const std::string&" per my coding style. Therefore, I chose to specify it in the model exactly how it will be used in the code. But this is a personal preference. Differently-skilled users of this model may get puzzled. A compromise has to be made. After all, the code will be auto-generated
* **Add only the minimum required**<br>
More stuff require more time and effort to maintain. Who wants that?

Here are more specifics:

* **_log_** - the root of XML document
* **_event_** - encapsulates a definition of an event
* **_event id_** - Each event needs to be identified uniquely and compactly. The ID is an integer and will be used as an index into an array that will hold priority levels for each event. Compactness requirement is aimed for more efficient RAM/network bandwidth/storage usage, log parsing speed, etc. Note that event ID 0 will be used to define program's priority level so as to filter out events that have lower priority than that
* **_event name_** - The name as it will appear in the code, macro name. This will also be used to convert compact log representation to user-friendly format
* **_event level_** - The priority level as defined in syslog(3) documentation
* **_doc_** - This standalone element should describe the event's purpose. For example, what program conditions exist at the moment the event is emitted, etc. The contents will also be added to source code comments
* **_param_** - a parameter encapsulates information about a single parameter
* **_param name_** - the name that will appear in the source code as a function parameter and in the comments. It will also be used to transform the format from compact to user-friendly
* **_param type_** - the parameter's C/C++ type. My requirement is to use numeric types and a constant std string reference
* **_param doc_** - this is to describe what the parameter represents in the context of the event. It is added to source code comments

That's it. I could also add XML schema to validate the content of this model, but only when it becomes needed.

[Part 3]({{ site.baseurl }}/Logger3) will describe output templates that the code generator will use during data-to-code transformation
