---
layout: post
title: "Log and metric reporting. Part 3"
---
[Part 2]({{ site.baseurl }}/Logger2) described a data model of events that a hypothetical program emits. [GSL](https://github.com/imatix/gsl#overview) would use that model and a template to generate C++ header and source files, ready to compile.<br>
Here is a snippet of the generated header file:

```c++
 18 /**
 19  * Log is emitted when so and so occurs.
 20  *
 21  * @param param1 signed 32-bit number
 22  * @param param2 describe me
 23  */
 24 #define onLogEventA(param1, param2) \
 25     if (Logger::instance()->filter(1)) { \
 26         Logger::instance()->onLogEventAImpl(param1, param2); \
 27     }
...
 58 class Logger {
 59 public:
 60 
...
103     void onLogEventAImpl(
104         int32_t param1,
105         int8_t param2) const;
```

This is an excerpt from a template to generate the header snippet above:

```c++
 22 .for log.event
 23 .   if defined(event->doc)
 24 /**
 25  * $(event->doc)
 26  *
 27 .   else
 28 /**
 29 .   endif
 30 .for event.param
 31  * @param $(param.name) $(param.doc?)
 32 .endfor
 33  */
 34 \
 35 #define $(event.name)(\
 36 .for event.param
 37 .   if index(param) > 1
 38 , \
 39 .   endif
 40 $(param.name)\
 41 .endfor
 42 ) \\
 43     if (Logger::instance()->filter($(event.id))) { \\
 44         Logger::instance()->$(event.name)Impl(\
 45 .       for event.param
 46 .           if index(param) > 1
 47 , \
 48 .           endif
 49 $(param.name)\
 50 .       endfor
 51 ); \\
 52     }
 53 
 54 .endfor
 ...
 63 class Logger {
 64 public:
 ...
108 .for log.event
109     void $(event.name)Impl(
110 .    for event.param
111 .       if last()
112         $(param.type) $(param.name)) const;
113 
114 .       else
115         $(param.type) $(param.name),
116 .       endif
117 .    endfor
118 .endfor
```

A line that starts with a dot begins a GSL instruction. The other lines are output as is but $(placeholder) tokens are replaced with the data from the model. Here is a break-down:

* **Line 22**: starts a loop for every element \<log>\<event> in the model
* **Lines 24-33**: outputs JavaDoc-style Doxygen comments. A brief description is taken from element \<event>\<doc>. Each parameter's name and associated documentation is output next
* **Lines 35-42**: outputs macro's identifier and parameter list. It results in line 24 of the header snippet above
* **Lines 43-52**: outputs macro's replacement tokens, which result in header's lines 25-27. Here the macro would check if an event is allowed to pass through given event's identifier and the associated priority level
* **Line 54**: completes the "for" loop for events
* **Lines 63-64**: outputs the beginning of Logger class declaration
* **Lines 108-118**: outputs a member function declaration (header lines 103-105)

As defined in cmake build script, once GSL completes generating the header file (logger.hpp), it proceeds to generate Logger class implementation (logger.cpp) from the same model, but using a different template - [logger.cpp.mdl](https://github.com/svkapustin/strong-log/blob/master/model/logger.cpp.mdl).

GSL outputs most of the template as is where the Logger class implementation is defined. That includes Logger singleton maker and access functions, priority level updating and filtering functions and other housekeeping. The translation of model definitions to the source code is defined by [lines 62-111](https://github.com/svkapustin/strong-log/blob/master/model/logger.cpp.mdl#L62-L111) of the template:

```c++
 62 .for log.event
 63 void Logger::$(event.name)Impl(
 64 .for event.param
 65 .   if last()
 66     $(param.type) $(param.name)) const {
 67 .   else
 68     $(param.type) $(param.name),
 69 .   endif
 70 .endfor
 71 
 72     syslog(levels_[$(event.id)], "$(event.id)\
 73 .for event.param
 74 ,%\
 75 .   if param.type = "uint8_t"
 76 " PRIu8 "\
 77 .   elsif param.type = "int8_t"
 78 " PRId8 "\
 79 .   elsif param.type = "uint16_t"
 80 " PRIu16 "\
 81 .   elsif param.type = "int16_t"
 82 " PRId16 "\
 83 .   elsif param.type = "uint32_t"
 84 " PRIu32 "\
 85 .   elsif param.type = "int32_t"
 86 " PRId32 "\
 87 .   elsif param.type = "uint64_t"
 88 " PRIu64 "\
 89 .   elsif param.type = "int64_t"
 90 " PRId64 "\
 91 .   elsif param.type = "const std::string&"
 92 s\
 93 .   endif
 94 .endfor
 95 ",
 96 .for event.param
 97 .   if index(param) > 1
 98 , \
 99 .   else
100         \
101 .   endif
102 .   if param.type = "const std::string&"
103 $(param.name).c_str()\
104 .   else
105 $(param.name)\
106 .   endif
107 .endfor
108 );
109 }
110 
111 .endfor
```

Here is an example of GSL-generated implementation in the source file:

```c++
 58 void Logger::onLogEventAImpl(
 59     int32_t param1,
 60     int8_t param2) const {
 61 
 62     syslog(levels_[1], "1,%" PRId32 ",%" PRId8 "",
 63         param1, param2);
 64 }
```

Similar logic to generating header file applies here as well. In addition to function signature, the generator outputs a call to syslog with the data formatted using comma-delimited string.

The purpose for using comma-delimited format to contain only values as opposed to including name tags and other supporting text is to:

* Use less CPU resources to generate
* Occupy smaller space in memory
* Use less bandwidth to transmit the message
* Make it easier and more efficient to process
* Have ability to represent the information in different ways. This will be explored further in [Part 4]({{ site.baseurl }}/Logger4) 

The program event captured and stored by syslog daemon is similar to the following:

```
2017-08-28T11:45:40.523085-04:00 vmu logger_test[19706]: 1,32,8
```
The event text consists of string "1,32,8" where "1" is an event identifier, "32" is first parameter's value, "8" is second parameter's value.

One of the main advantages of auto-generating the code like described above is that if system requirements change (e.g., use standard output instead of syslog, use different format than CSV, etc.), only a single line/block of template will need to be changed. All other events will be replicated from that.

[Part 4]({{ site.baseurl }}/Logger4) will describe a log viewer script generated from the model, and provide concluding notes

