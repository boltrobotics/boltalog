// Copyright (C) 2019 Bolt Robotics <info@boltrobotics.com>
// License: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

////////////////////////////////////////////////////////////////////////////////////////////////////
// WARNING: The code is auto-generated. Any changes will be overwritten.
////////////////////////////////////////////////////////////////////////////////////////////////////

// PROJECT INCLUDES
#include "logger.hpp" // class implemented
#include "boltalog/defines.hpp"

#if BTR_LOG_ENABLED > 0

#if BTR_X86 > 0
#define BOLTALOG_EOL() ""
#include "spdlog/spdlog.h"
#define PROGMEM

#elif BTR_ARD > 0
#define BOLTALOG_EOL() "\r\n"
#include <Arduino.h>
#include <avr/pgmspace.h>
#include <string.h>

#elif BTR_AVR > 0
#define BOLTALOG_EOL() "\r\n"
#include <avr/pgmspace.h>
#include <string.h>
#include "devices/avr/usart.hpp"
#include "devices/avr/time.hpp"

#elif BTR_STM32 > 0
#define BOLTALOG_EOL() "\r\n"
#include "devices/stm32/usb.hpp"
#include "devices/stm32/usart.hpp"
#define PROGMEM
#endif // x86, ard, avr, stm32

// AVR libc doesn't define these macros
#if !defined(PRIu64)
#define PRIu64 "llu"
#endif
#if !defined(PRId64)
#define PRId64 "ll"
#endif

// SYSTEM INCLUDES
#include <stdio.h>

#endif // BTR_LOG_ENABLED > 0

<TMPL_foreach namespace as n->
namespace <TMPL_var n>
{

</TMPL_foreach->

#if BTR_LOG_ENABLED > 0

static Logger logger_;
static const char lut[] = "0123456789ABCDEF";

uint32_t toHex(const char* src_str, uint32_t src_size, char* dst_str, uint32_t dst_size)
{
  // Includes null character.
  uint32_t total_size = src_size * 3;

  if (src_size == 0 || dst_size < total_size) {
    return -1;
  }

  for (uint32_t i = 0, j = 0; i < src_size; i++, j += 3) {
    const uint8_t c = src_str[i];
    dst_str[j] = lut[c >> 4];
    dst_str[j + 1] = lut[c & 0xF];

    if ((i + 1) < src_size) {
      dst_str[j + 2] = ':';
    }
  }
  dst_str[total_size - 1] = '\0';
  return total_size;
}

#endif // BTR_LOG_ENABLED > 0

/////////////////////////////////////////////// PUBLIC /////////////////////////////////////////////

//============================================= LIFECYCLE ==========================================

Logger::Logger()
{
#if BTR_LOG_ENABLED > 0
  levels_[0] = BTR_LOG_LEVEL;

  <TMPL_foreach events as e->
  levels_[<TMPL_var e.id>] = btr::log::<TMPL_var e.level>;
  </TMPL_foreach>
#endif // BTR_LOG_ENABLED > 0
}

//============================================= OPERATIONS =========================================

// static
#if BTR_X86 > 0
Logger* Logger::instance(std::shared_ptr<spdlog::logger>* backend)
{
#if BTR_LOG_ENABLED > 0
  if (nullptr != backend) {
    logger_.backend_ = *backend;
  }
  return &logger_;
#else
  (void) backend;
  return nullptr;
#endif // BTR_LOG_ENABLED > 0
}

#elif BTR_ARD > 0

Logger* Logger::instance(HardwareSerial* backend)
{
#if BTR_LOG_ENABLED > 0
  if (nullptr != backend) {
    logger_.backend_ = backend;
  }
  return &logger_;
#else
  (void) backend;
  return nullptr;
#endif // BTR_LOG_ENABLED > 0
}

#elif BTR_AVR > 0

Logger* Logger::instance(btr::Usart* backend)
{
#if BTR_LOG_ENABLED > 0
  if (nullptr != backend) {
    logger_.backend_ = backend;
  }
  return &logger_;
#else
  (void) backend;
  return nullptr;
#endif // BTR_LOG_ENABLED > 0
}

#elif BTR_STM32_LOGGER_USB > 0
Logger* Logger::instance(btr::Usb* backend)
{
#if BTR_LOG_ENABLED > 0
  if (nullptr != backend) {
    logger_.backend_ = backend;
  }
  return &logger_;
#else
  (void) backend;
  return nullptr;
#endif // BTR_LOG_ENABLED > 0
}
#elif BTR_STM32_LOGGER_USART > 0
Logger* Logger::instance(btr::Usart* backend)
{
#if BTR_LOG_ENABLED > 0
  if (nullptr != backend) {
    logger_.backend_ = backend;
  }
  return &logger_;
#else
  (void) backend;
  return nullptr;
#endif // BTR_LOG_ENABLED > 0
}
#endif

// static 
const char* Logger::strerror(int errnum)
{
  switch (errnum) {
  case EBADLOGLEVEL:
    return "Bad log level";
  default:
    return "Unknown";
  }
}

int Logger::level(int event_id, int log_level)
{
#if BTR_LOG_ENABLED > 0
  int prev_event_id = -1;

  if (event_id < (int)(sizeof(levels_) / sizeof(int))) {
    prev_event_id = levels_[event_id];
    levels_[event_id] = log_level;
  }
  return prev_event_id;
#else
  (void) event_id; (void) log_level;
  return -1;
#endif // BTR_LOG_ENABLED > 0
}

bool Logger::filter(int event_id) const
{
#if BTR_LOG_ENABLED > 0
  if (event_id < (int)(sizeof(levels_) / sizeof(int)) && levels_[event_id] >= levels_[0]) {
    return true;
  } else {
    return false;
  }
#else
  (void) event_id;
  return false;
#endif // BTR_LOG_ENABLED > 0
}

int Logger::shortLogLevel(int level)
{
  switch (level) {
    case btr::log::TRACE:
      return 'T';
    case btr::log::DEBUG:
      return 'D';
    case btr::log::INFO:
      return 'I';
    case btr::log::WARN:
      return 'W';
    case btr::log::ERROR:
      return 'E';
    case btr::log::CRITICAL:
      return 'C';
    default:
      return 'O';
  }
}

#if BTR_LOG_ENABLED > 0
<TMPL_foreach events as e->

<TMPL_var COUNT(1)->
int Logger::<TMPL_var e.name>Impl(
  <-TMPL_if DEFINED(params)->

  <TMPL_foreach params as p->
  <TMPL_if !(p.__first__)->,
  <TMPL_var PARAMMAPPER(p.type, p.name)->
  <TMPL_else>
  <TMPL_var PARAMMAPPER(p.type, p.name)->
  </TMPL_if->
  </TMPL_foreach->)

  <-TMPL_else->)
  <-/TMPL_if>
{
  char buff[MAX_LOG_SIZE];
  <TMPL_if DEFINED(params)->
  <TMPL_foreach params as p->
  <-TMPL_var PREPSTRING(p.type, p.name)>
  <-/TMPL_foreach->
  </TMPL_if>
  int cx = snprintf(buff, MAX_LOG_SIZE,
#if BTR_AVR > 0 | BTR_ARD > 0 | BTR_STM32 > 0
    "%6lu.%03lu %c [0]: "
#endif
    "<TMPL_var e.id>"
    <TMPL_if DEFINED(params)->

    <TMPL_foreach params as p->
    ",%" <TMPL_var FORMATSPEC(p.type)> ""
    <-/TMPL_foreach> BOLTALOG_EOL(),
#if BTR_AVR > 0
    btr::Time::sec(), (btr::Time::millis() % 1000), shortLogLevel(levels_[<TMPL_var e.id>]),
#elif BTR_ARD > 0
    (millis() / 1000), (millis() % 1000), shortLogLevel(levels_[<TMPL_var e.id>]),
#elif BTR_STM32 > 0 // TODO
    (uint32_t) 0, (uint32_t) 0, shortLogLevel(levels_[<TMPL_var e.id>]),
#endif
    <TMPL_foreach params as p->
    <TMPL_if !p.__first__>,</TMPL_if><TMPL_var FORMATPARAMS(p.type, p.name)>
    <-/TMPL_foreach>
    <TMPL_else->
#if BTR_AVR > 0
    , btr::Time::sec(), (btr::Time::millis() % 1000), shortLogLevel(levels_[<TMPL_var e.id>])
#elif BTR_ARD > 0
    , (millis() / 1000), (millis() % 1000), shortLogLevel(levels_[<TMPL_var e.id>])
#elif BTR_STM32 > 0 // TODO
    , (uint32_t) 0, (uint32_t) 0, shortLogLevel(levels_[<TMPL_var e.id>])
#endif
    </TMPL_if>);

  return log(cx, levels_[<TMPL_var e.id>], buff);
}

</TMPL_foreach->

#endif // BTR_LOG_ENABLED > 0

/////////////////////////////////////////////// PRIVATE ////////////////////////////////////////////

//============================================= OPERATIONS =========================================

#if BTR_LOG_ENABLED > 0

int Logger::log(int cx, int level, const char* msg)
{
  int rc = -1;

  if (nullptr != backend_) {
    if (cx >= 0) {
#if BTR_X86 > 0
      switch (level) {
        case btr::log::TRACE:
          backend_->trace(msg);
          break;
        case btr::log::DEBUG:
          backend_->debug(msg);
          break;
        case btr::log::INFO:
          backend_->info(msg);
          break;
        case btr::log::WARN:
          backend_->warn(msg);
          break;
        case btr::log::ERROR:
          backend_->error(msg);
          break;
        case btr::log::CRITICAL:
          backend_->critical(msg);
          break;
        default:
          errno = EBADLOGLEVEL;
          return rc;
      };
#elif BTR_ARD > 0
      (void) level;
      backend_->print(msg);
#elif BTR_AVR > 0 || BTR_STM32 > 0
      (void) level;
      backend_->send(msg, strlen(msg));
#endif

      if (cx < MAX_LOG_SIZE) {
        rc = 0;
      } else {
        // AVR libc doesn't define EOVERFLOW, just use ERANGE
        errno = ERANGE;
      }
    }
  } else {
    errno = EINVAL;
  }
  return rc;
}
#endif // BTR_LOG_ENABLED > 0
<TMPL_foreach namespace as n>
} // namespace <TMPL_var n>
</TMPL_foreach>
